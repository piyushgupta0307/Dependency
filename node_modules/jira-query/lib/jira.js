'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setUrl = setUrl;
exports.getInfoByIssueId = getInfoByIssueId;
exports.searchForIssues = searchForIssues;
exports.getMyIssues = getMyIssues;
exports.getMyOpenIssues = getMyOpenIssues;
exports.getIssue = getIssue;

var _nodeFetch = require('node-fetch');

var _nodeFetch2 = _interopRequireDefault(_nodeFetch);

var _auth = require('./auth');

var _queries = require('./queries');

var QUERY = _interopRequireWildcard(_queries);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var jiraUrl = ''; // @jira


function needsCaptcha(resp) {
  return resp.headers.get('x-seraph-loginreason') === 'AUTHENTICATION_DENIED';
}

function getCaptchaUrl(resp) {
  var header = resp.headers.get('x-authentication-denied-reason');
  return header.split('=').pop();
}

function handleBadResponse(resp) {
  if (!resp.ok) {
    switch (resp.status) {
      case 403:
        if (needsCaptcha(resp)) {
          throw new Error('CAPTCHA needed, ' + getCaptchaUrl(resp));
        } else {
          throw new Error('user is not authenticated');
        }

      case 401:
        throw new Error('user is not authenticated');

      case 404:
        throw new Error('appears to be an invalid Jira url');

      default:
        throw new Error(resp.status + ': ' + resp.statusText);
    }
  } else {
    return resp;
  }
}

function setUrl(url) {
  jiraUrl = url;
}

function getInfoByIssueId(issueId) {
  var auth = (0, _auth.getAuthHeader)();
  var url = jiraUrl + '/rest/api/2/issue/' + issueId + '?fields=status,assignee,description';
  var options = {
    headers: {
      Accept: 'application/json',
      'Content-Type': 'application/json',
      Authorization: auth
    }
  };

  return new Promise(function (resolve, reject) {
    (0, _nodeFetch2.default)(url, options).then(function (resp) {
      if (resp.ok) {
        return resolve(resp.json());
      } else {
        reject(new Error('unable to get issue'));
      }
    });
  });
}

function searchForIssues(jql) {
  var auth = (0, _auth.getAuthHeader)();
  var url = jiraUrl + '/rest/api/2/search';
  var options = {
    headers: {
      Accept: 'application/json',
      'Content-Type': 'application/json',
      Authorization: auth
    },
    method: 'POST',
    body: JSON.stringify({ jql: jql })
  };

  return (0, _nodeFetch2.default)(url, options).then(handleBadResponse).then(function (resp) {
    return resp.json();
  }).then(function (resp) {
    return resp.issues;
  }).catch(function (err) {
    throw new Error('unable to perform search: ' + err.message);
  });
}

function getMyIssues() {
  return searchForIssues(QUERY.MY_ISSUES);
}

function getMyOpenIssues() {
  return searchForIssues(QUERY.MY_ISSUES_OPEN);
}

function getIssue(key) {
  return getInfoByIssueId(key);
}